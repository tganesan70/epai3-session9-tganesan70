# -*- coding: utf-8 -*-
"""session9_pynotes_tests.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11jZmziaBT_WYfDyuV4zD0wC0nv2OnqO6
"""

from functools import wraps
from collections import namedtuple
from functools import reduce
import random
import operator
#from session9 import *

#!pip install faker    # <---------   uncomment this once to install faker

# Timed decorator for all functions - but using a global variable for elapsed time in case we want it at __main__ level
elapsed_time = 0
def timed(fn: 'Function name') -> 'Time for execution of the function':
    """
    A function decorator to compute the execution time for all the functions in this module when called
    from the test script.
    Params:
    fn - Function name
    Returns:
        Time for execution in seconds
    """
    from time import perf_counter
    @wraps(fn)
    def inner(*args, **kwargs):
        global elapsed_time
        start_time = perf_counter()
        result = fn(*args, **kwargs)
        end_time = perf_counter()
        elapsed_time = end_time - start_time
        print(f"Function {fn.__name__}() took {elapsed_time} secs to execute")
        return result
    return inner

# Function decorator for checking the docstring of functions
def check_doc_string(fn: 'Function name that needs to be parsed') -> 'Returns True if the function has 50 words of description':
    """
    This function checks whether the function passed on to this has atleast 50 words of
    description.
    :param fn: Function name that is passed to this function
    :return: Returns a closure which allows the free variables can be accessed later
             The inner function Returns True if it has 50 or more words in its docstring description, else False
    Question: Will the docstring include the argument description function as well?  A BIG NO!
    """
    comment_len = 50
    """
    Doc string for inner function
    :param args: Positional arguments for the function
    :param kwargs:Function arguments for the function
    :return: The function output
    """
    if fn.__doc__ is None:
        return False
    else:
        fn_doc_string = fn.__doc__.split(sep=" ")
        # print(f'No. of words in the docstring comment for {fn.__name__}() is : {len(fn_doc_string)}')
        if len(fn_doc_string) < comment_len:
            return False
        else:
            return True

@timed
def create_fake_profile_tuples(num: 'Int - No. of profiles') -> 'Returns the list of Fake profiles (namedtuples)':
    """
    Params:
        num - No. of profiles
    Returns:
        list of namedtuples with the following fields in them:
              profile = namedtuple('profile', 'name, age, latt, ,long, blood_group')
    """
    from faker import Faker
    profile = namedtuple('Profile', 'name, age, lattitude, longitude, blood_group')
    profile_list = []
    for i in range(num):
        fake = Faker()
        profile_list.append(profile(fake.name(),
                            round(random.uniform(1, 120)),
                            fake.coordinate(),
                            fake.longitude(),
                            random.choice(['a', 'b', 'ab', 'o']) + random.choice(['+', '-'])))
    return profile_list

profile_list = create_fake_profile_tuples(10)
print(profile_list)

#Test case 1: Test for invalid inputs for creating the stock list
stocks_list = create_fake_stocks_tuples(0)   # Uncomment this once to check failure

@timed
def find_max_blood_group_tuples(profile_list: 'list of Fake profiles (namedtuples)'):
    """
    Find the largest blood group in the list of profiles (namedtuples) with the format given as below
    Params: List of profiles of type
         profile = namedtuple('profile', 'name, age, latt, ,long, blood_group')
    Returns: The largest blood group in all the profiles
    """
    aplus_cnt = sum([profile_list[i].blood_group == 'a+' for i in range(len(profile_list))])
    aminus_cnt = sum([profile_list[i].blood_group == 'a-' for i in range(len(profile_list))])
    bplus_cnt = sum([profile_list[i].blood_group == 'b+' for i in range(len(profile_list))])
    bminus_cnt = sum([profile_list[i].blood_group == 'b-' for i in range(len(profile_list))])
    oplus_cnt = sum([profile_list[i].blood_group == 'o+' for i in range(len(profile_list))])
    ominus_cnt = sum([profile_list[i].blood_group == 'o-' for i in range(len(profile_list))])
    abplus_cnt = sum([profile_list[i].blood_group == 'ab+' for i in range(len(profile_list))])
    abminus_cnt = sum([profile_list[i].blood_group == 'ab-' for i in range(len(profile_list))])

    max_cnt = max([aplus_cnt, aminus_cnt, bplus_cnt, bminus_cnt, abplus_cnt, abminus_cnt, oplus_cnt, ominus_cnt])
    if max_cnt == aplus_cnt:
        return 'a+', max_cnt
    elif max_cnt == aminus_cnt:
        return 'a-', max_cnt
    elif max_cnt == bplus_cnt:
        return 'b+', max_cnt
    elif max_cnt == bminus_cnt:
        return 'b-', max_cnt
    elif max_cnt == abplus_cnt:
        return 'ab+', max_cnt
    elif max_cnt == abminus_cnt:
        return 'ab-', max_cnt
    elif max_cnt == oplus_cnt:
        return 'o+', max_cnt
    else:
        return 'o-', max_cnt

@timed
def find_mean_latt_long_tuples(
    profile_list: 'list of Fake profiles (namedtuples)') -> 'The mean lattitude and longitude of the location of the group':
    """
    Find the mean location (latt, long) for all people in the random group
    Params: List of profiles of type
         profile = namedtuple('profile', 'name, age, latt, ,long, blood_group')
    Returns: The mean location for the group
    """
    mean_latt = sum([profile_list[i].lattitude for i in range(len(profile_list))]) / len(profile_list)
    mean_long = sum([profile_list[i].longitude for i in range(len(profile_list))]) / len(profile_list)
    return mean_latt, mean_long

@timed
def find_max_avg_age_tuples(profile_list: 'list of Fake profiles (namedtuples)') -> 'The maximum age among the group':
    """
    Find the mean location (latt, long) for all people in the random group
    Params: List of profiles of type
         profile = namedtuple('profile', 'name, age, latt, ,long, blood_group')
    Returns: The maximum and average age in the group
    """
    max_age = max([profile_list[i].age for i in range(len(profile_list))])
    avg_age = round(sum([profile_list[i].age for i in range(len(profile_list))]) / len(profile_list))
    return max_age, avg_age

@timed
def create_fake_profile_dict(num: 'Int - No. of profiles') -> 'Returns the list of Fake profiles (dictionaries)':
    """
    Params:
        num - No. of profiles
    Returns:
        list of dictionaries with the following fields in them:
              profile = dictionary('profile', 'name, age, latt, ,long, blood_group')
    """
    from faker import Faker
#profile = dict(name = "",
#               age = "",
#               lattitude = "",
#               longitude = "",
#               blood_group = "")
    profile_list = []
    for i in range(num):
        fake = Faker()
        profile_list.append(dict(name=fake.name(),  # name
                                age=round(random.uniform(1, 120)),  # age
                                lattitude=fake.coordinate(),  # latt
                                longitude=fake.longitude(),  # long
                                blood_group=random.choice(['a', 'b', 'ab', 'o']) + random.choice(['+', '-'])  # bloodgroup
                                ))
    return profile_list


@timed
def find_max_blood_group_dict(profile_list: 'list of Fake profiles (dictionaries)'):
    """
    Find the largest blood group in the list of profiles (dictionaries) with the format given as below
    Params: List of profiles of type
         profile = namedtuple('profile', 'name, age, latt, ,long, blood_group')
    Returns: The largest blood group in all the profiles
    """
    aplus_cnt = sum([profile_list[i]['blood_group'] == 'a+' for i in range(len(profile_list))])
    aminus_cnt = sum([profile_list[i]['blood_group'] == 'a-' for i in range(len(profile_list))])
    bplus_cnt = sum([profile_list[i]['blood_group'] == 'b+' for i in range(len(profile_list))])
    bminus_cnt = sum([profile_list[i]['blood_group'] == 'b-' for i in range(len(profile_list))])
    oplus_cnt = sum([profile_list[i]['blood_group'] == 'o+' for i in range(len(profile_list))])
    ominus_cnt = sum([profile_list[i]['blood_group'] == 'o-' for i in range(len(profile_list))])
    abplus_cnt = sum([profile_list[i]['blood_group'] == 'ab+' for i in range(len(profile_list))])
    abminus_cnt = sum([profile_list[i]['blood_group'] == 'ab-' for i in range(len(profile_list))])

    max_cnt = max([aplus_cnt, aminus_cnt, bplus_cnt, bminus_cnt, abplus_cnt, abminus_cnt, oplus_cnt, ominus_cnt])
    if max_cnt == aplus_cnt:
        return 'a+', max_cnt
    elif max_cnt == aminus_cnt:
        return 'a-', max_cnt
    elif max_cnt == bplus_cnt:
        return 'b+', max_cnt
    elif max_cnt == bminus_cnt:
        return 'b-', max_cnt
    elif max_cnt == abplus_cnt:
        return 'ab+', max_cnt
    elif max_cnt == abminus_cnt:
        return 'ab-', max_cnt
    elif max_cnt == oplus_cnt:
        return 'o+', max_cnt
    else:
        return 'o-', max_cnt


@timed
def find_mean_latt_long_dict(
        profile_list: 'list of Fake profiles (dictionaries)') -> 'The mean lattitude and longitude of the location of the group':
    """
    Find the mean location (latt, long) for all people in the random group
    Params: List of profiles of type
         profile = namedtuple('profile', 'name, age, latt, ,long, blood_group')
    Returns: The mean location for the group
    """
    mean_latt = sum([profile_list[i]['lattitude'] for i in range(len(profile_list))]) / len(profile_list)
    mean_long = sum([profile_list[i]['longitude'] for i in range(len(profile_list))]) / len(profile_list)
    return mean_latt, mean_long


@timed
def find_max_avg_age_dict(profile_list: 'list of Fake profiles (dictionaries)') -> 'The maximum age among the group':
    """
    Find the mean location (latt, long) for all people in the random group
    Params: List of profiles of type
         profile = namedtuple('profile', 'name, age, latt, ,long, blood_group')
    Returns: The maximum and average age in the group
    """
    max_age = max([profile_list[i]['age'] for i in range(len(profile_list))])
    avg_age = round(sum([profile_list[i]['age'] for i in range(len(profile_list))]) / len(profile_list))
    return max_age, avg_age

print("### ---------------------------------------- ###")
print("### Tests for namedtuples based random group ###")
print("### ---------------------------------------- ###")
# Test 1: Create the random population of 10000 people
profile_list = create_fake_profile_tuples(100)  #  It takes about 17s for 1000, 2s for 100

# Test 2: Find the majority blood group
max_bg_type, max_cnt = find_max_blood_group_tuples(profile_list)
print(f'The largest blood group type is: {max_bg_type} ({max_cnt} out of {len(profile_list)})')

# Test 3: Get the mean location
mean_latt, mean_long = find_mean_latt_long_tuples(profile_list)
print(f'For the group, the mean (latt,long) coordinates are : ({mean_latt}, {mean_long})')

# Test 4: Get the average and maximum age in the group
max_age, avg_age = find_max_avg_age_tuples(profile_list)
print(f'Among the group members, the highest age is : {max_age}, and the average age is {avg_age}')

print("### ---------------------------------------- ###")
print("### Tests for dictionary based random group  ###")
print("### ---------------------------------------- ###")
# Test 5: Create the random population of 10000 people
profile_list = create_fake_profile_dict(100) #  It takes about 17s for 1000, 2s for 100

# Test 6: Find the majority blood group
max_bg_type, max_cnt = find_max_blood_group_dict(profile_list)
print(f'The largest blood group type is: {max_bg_type} ({max_cnt} out of {len(profile_list)})')

# Test 7: Get the mean location
mean_latt, mean_long = find_mean_latt_long_dict(profile_list)
print(f'For the group, the mean (latt,long) coordinates are : ({mean_latt}, {mean_long})')

# Test 8: Get the average and maximum age in the group
max_age, avg_age = find_max_avg_age_dict(profile_list)
print(f'Among the group members, the highest age is : {max_age}, and the average age is {avg_age}')

# Test cases for stock index
stocks_list = create_fake_stocks_tuples(1)
stocks_list = create_fake_stocks_tuples(10)
print(f'No. of entries in the index: {len(stocks_list)}')
print('The stock index details are:')
for i in range(10):
    print(stocks_list[i])

#Test case 2: Test for invalid data type values in the stock list
for i in range(len(stocks_list)):
    assert ((type(getattr(stocks_list[i],'name')) is str)   and (type(getattr(stocks_list[i],'symbol')) is str) and
        (type(getattr(stocks_list[i],'open')) is float) and (type(getattr(stocks_list[i],'close')) is float) and
        (type(getattr(stocks_list[i],'high')) is float) and (type(getattr(stocks_list[i],'low')) is float)) == True, "Wrong data type in stock list"

#Test case 3: Test for invalid length in the symbol string
for i in range(len(stocks_list)):
    #print(len(getattr(stocks_list[i],'symbol')))
    assert len(getattr(stocks_list[i],'symbol')) == 6, "Symbol length is wrong"

#Test case 4: Test for invalid values of open, close, hi and lo
for i in range(len(stocks_list)):
    #print(stocks_list[i].open, stocks_list[i].high, stocks_list[i].low, stocks_list[i].close)
    assert ((stocks_list[i].high > stocks_list[i].low) or
           (stocks_list[i].high > stocks_list[i].open) or
           (stocks_list[i].high > stocks_list[i].close)), "Stock high value is wrong"
    assert ((stocks_list[i].low < stocks_list[i].high) or
            (stocks_list[i].low < stocks_list[i].open) or
            (stocks_list[i].low < stocks_list[i].close)), "Stock low value is wrong"

#Test case 5: Test for invalid number of entries in the stock list
assert (len(stocks_list) == 10), "No. of stocks in index is not correct"

#Test case 6: Test for invalid weights used in the index
wts = set_stock_weights(stocks_list)
print(f'Sum of weights = {sum(wts)}, No. of weights = {len(wts)}')
assert isclose(sum(wts),1.0), "All weights must constitute 100%"

#Test case 7: Test for invalid range of the weight values
wts = set_stock_weights(stocks_list)
assert all([0 <= wts[i] < 1 for i in range(len(wts))]) == True, "All weights must be less than 100%"

#Test case 8: Test for -ve values in weight values
#print([wts[i] for i in range(len(wts))])
assert all([wts[i] >= 0 for i in range(len(wts))]) == True, "Weights cannot be negative"

#Test case 9: Test for zero values in stock values
for i in range(len(stocks_list)):
    assert all([[stocks_list[i].low > 0, stocks_list[i].open > 0, stocks_list[i].close > 0, stocks_list[i].high > 0]
            for i in range(len(stocks_list))]) == True, "Zero stock values not expected"

#Test case 10: Test for rounding errors in index computation
Sopen, Shi, Slow, Sclose = calc_index_value(stocks_list,wts)
index_close, index_open, index_high, index_low  = 0,0,0,0
for i in range(len(stocks_list)):
    index_close += stocks_list[i].close * wts[i]
    index_open += stocks_list[i].open * wts[i]
    index_high += stocks_list[i].high * wts[i]
    index_low += stocks_list[i].low * wts[i]
assert (isclose(index_close,Sclose) and isclose(Sopen, index_open) and
       isclose(index_high, Shi) and isclose(index_low, Slow)), "Rounding error is too high"

Sopen, Shi, Slow, Sclose = calc_index_value(stocks_list,wts)
print(f'Stock index values-- Open: {Sopen}, High: {Shi}, Low: {Slow}, Close:{Sclose}')